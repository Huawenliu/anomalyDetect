import numpy as np

def combine_scores(matrix_of_scores, method='avg', **kwargs):
    '''
    Input:
        `matrix_of_scores` - a matrix where each column is a vector of scores generated by one method for all the dataset's samples
        `method` - how to combine the scores
    '''
    n = matrix_of_scores[0]
    
    matrix_of_rankings = np.argsort(np.argsort(matrix_of_scores, axis=0), axis=0) # larger is more anomalous, so 0 is least anomalous and n is most
    
    if method == 'avg':
        return matrix_of_scores.mean(axis=1)
    elif method == 'prod':
        return matrix_of_scores.prod(axis=1)
    elif method == 'median_rank':
        rankings = np.median(matrix_of_rankings, axis=1)
        return rankings
    elif method == 'max_rank':
        rankings = np.max(matrix_of_rankings, axis=1)
        return rankings
    elif method == 'min_rank':
        rankings = np.min(matrix_of_rankings, axis=1)
        return rankings
    elif method == '75_rank':
        rankings = np.percentile(matrix_of_rankings, 75, axis=1)
        return rankings
    elif method == 'greedy_ensemble':
        '''
        Build a "greedy ensemble" (see reference). 
        
        Reference: Erich Schubert, Remigius Wojdanowski, Arthur Zimek, 
        Hans-Peter Kriegel, "On Evaluation of Outlier Rankings and Outlier 
        Scores"
        '''
        
        def weighted_pearson_correlation(u, v, w):
            '''
            Calculates the weighted (with weights `w`) pearson correlation between
            u and v
            
            TODO: make faster?
            '''
            # Normalize w so it sums to 1
            if np.sum(w) != 1.:
                w = w / np.sum(w)
            
            u = u.flatten()
            v = v.flatten()
            
            mean_u = w.dot(u)
            var_u = w.dot((u - mean_u)**2)
            
            mean_v = w.dot(v)
            var_v = w.dot((v - mean_v)**2)
            
            cov_uv = np.sum((u - mean_u)*(v - mean_v)*(w))
            rho = cov_uv / np.sqrt(var_u) / np.sqrt(var_v)
            
            return rho
        
        k = kwargs.get('k', None)
        if k is None:
            raise Exception("Missing parameter k")
        ensemble_indices = kwargs.get('ensemble_indices', False)
        m, t = matrix_of_scores.shape
        
        # Create "target" vector (NOT used as the actual result)
        top_k_union = np.unique(np.argsort(-matrix_of_scores, axis=0)[:k])
        target_vec = np.zeros(m)
        target_vec[top_k_union] = 1
        K = len(top_k_union)
        
        # Weights for the weighted Pearson correlation
        w = np.empty(m)
        w[:] = K
        w[top_k_union] = m-K
        
        # Ensemble selection
        in_ensemble = np.repeat(False, t)
        detectors = set(range(t))
        
        # Initialize, find detector with highest weighted Pearson correlation 
        # to target vector
        corrs = [weighted_pearson_correlation(target_vec, matrix_of_scores[:, j], w) for j in range(t)]
        i = np.argmax(corrs)
        in_ensemble[i] = True
        detectors.discard(i)
        while detectors:
            detectors_ = list(detectors)
            
            # Find detector with lowest correlation to the current ensemble
            corrs= [weighted_pearson_correlation(target_vec, matrix_of_scores[:, j], w) for j in detectors_]
            i = detectors_[np.argmin(corrs)]
            
            # Decide whether to add this detector to the ensemble
            curr_ensemble_scores = np.mean(matrix_of_scores[:, in_ensemble], axis=1)
            curr_ensemble_corr_with_target = weighted_pearson_correlation(target_vec, curr_ensemble_scores, w)
            in_ensemble[i] = True
            new_ensemble_scores = np.mean(matrix_of_scores[:, in_ensemble], axis=1)
            new_ensemble_corr_with_target = weighted_pearson_correlation(target_vec, new_ensemble_scores, w)
            if new_ensemble_corr_with_target <= curr_ensemble_corr_with_target:
                in_ensemble[i] = False
            
            detectors.discard(i)
        
        if ensemble_indices:
            return (np.mean(matrix_of_scores[:, in_ensemble], axis=1), in_ensemble)
        else:
            return np.mean(matrix_of_scores[:, in_ensemble], axis=1)
    else:
        raise Exception("Unknown method")